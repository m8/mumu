{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to mumu mumu is a hobby hypervisor-ish. mumu can be a good resource to learn virtualization, hypervisors and KVM right now. In the future, who knows, it may become a real hypervisor. o o o o ______ o _/ ( \\_ _ _/ ( \\_ O | \\_ _/ ( ( 0 \\ |== \\_/ ( ( | |=== _ ( ( ( | |==_/ \\_ ( ( | |_/ \\_ ( ( \\__/ \\_ ( _/ | |___/ /__/ Navigate Getting Started Reference Examples","title":"Welcome to mumu"},{"location":"#welcome-to-mumu","text":"mumu is a hobby hypervisor-ish. mumu can be a good resource to learn virtualization, hypervisors and KVM right now. In the future, who knows, it may become a real hypervisor. o o o o ______ o _/ ( \\_ _ _/ ( \\_ O | \\_ _/ ( ( 0 \\ |== \\_/ ( ( | |=== _ ( ( ( | |==_/ \\_ ( ( | |_/ \\_ ( ( \\__/ \\_ ( _/ | |___/ /__/","title":"Welcome to mumu"},{"location":"#navigate","text":"Getting Started Reference Examples","title":"Navigate"},{"location":"architecture/","text":"Architecture & Design mumu uses KVM in the background to run virtual machines. It also makes use of posix threads and posix libraries. Partition VM mumu calls each VM as Partition VM . From now on partition vms will be referred to as partition. When a partition starts, it have a 6MB of space. In this area, page tables are given to the user as a 1:1 map. In this way, injection can be made easily through physical and virtual addresses during the first boot phase. +--------------------+ 0x0000000 User Start |++++++++++++++++++++| |++++++++++++++++++++| |++++++++++++++++++++| |++++++++++++++++++++| |++++++++++++++++++++| +--------------------+ 0x1000000 Page Table Entries | | +--------------------+ | | +--------------------+ | | +--------------------+ 0x1400000 Channel Informations | | | ^ ^ ^ | | | | | | | | | | | 0x600000 Stack +---+-----+-----+----+ SINGLE PARTITION Partitions should be defined under the <Partitions> node in XML file. Each partition should similar to this: <Partition> <PartitionDefinition Identifier=\"1\" Name=\"test1\" BinaryPath=\"hello.bin\" ScheduleChangeAction=\"IDLE\" SetModuleSchedule=\"false\" SystemPartition=\"true\"/> <PartitionPeriodicity Duration=\"20000000\" Period=\"3000\"/> <CoreAffinity> <CoreMapping LogicalCoreId=\"0\" PhysicalCoreId=\"3\"/> <CoreMapping LogicalCoreId=\"1\" PhysicalCoreId=\"2\"/> </CoreAffinity> </Partition> Multicore mumu can run different vcpu\u2019s in different cores thanks to posix threads. In XML file programmers should explicitly define affinity of the cores. +-------+---------------+ |Core 1 | VM-1 VCPU1 | +-------+---------------+ |Core 2 | VM-1 VCPU2 | +-------+---------------+ |Core 3 | VM-2 VCPU1 | +-------+---------------+ In XML file programmer should define as follow: <CoreAffinity> <CoreMapping LogicalCoreId=\"0\" PhysicalCoreId=\"3\"/> <CoreMapping LogicalCoreId=\"1\" PhysicalCoreId=\"2\"/> </CoreAffinity> Static Scheduling Static scheduling is a mechanism that allows to regulate the order in which threads execute in the code. When we look at the mumu level, we see that these are vms. 0ms 50ms 120ms 150ms +------------+-------------------+-----------+ Core 1 | VM1 VCPU1 | VM3 VCPU1 | VM2 VCPU3 | +------------+-------------------+-----------+ Core 2 | VM1 VCPU2 | VM2 VCPU2 | VM1 VCPU2 | +------------+-------------------+-----------+ Core 3 | VM2 VCPU2 | VM1 VCPU1 | VM2 VCPU2 | +------------+-------------------+-----------+ Core 4 | VM3 VCPU1 | VM2 VCPU1 | VM1 VCPU1 | +------------+-------------------+-----------+ We can measure scheduling times with uftrace thanks to the mumu runs on C++. The static schedule structure can be seen on uftrace as follows. Scheduling times can be configured through XML file. <Schedules MajorFrameDuration=\"60000000\" ScheduleIdentifier=\"1\" InitialModuleSchedule=\"true\"> <PartitionTimeWindow PartitionNameRef=\"test1\" Duration=\"2000\" Offset=\"0\" /> <PartitionTimeWindow PartitionNameRef=\"test2\" Duration=\"2000\" Offset=\"20000000\" /> <PartitionTimeWindow PartitionNameRef=\"test1\" Duration=\"2000\" Offset=\"40000000\" /> <PartitionTimeWindow PartitionNameRef=\"test1\" Duration=\"2000\" Offset=\"60000000\" /> </Schedules> Shared Memory Qemu uses the ivshmem infrastructure for shared memory. Actually, ivhsmem is installed in Linux devices as a PCI device. Then, communication can take place by read and write syscalls to these PCI devices. Ivhsmem has a lot of features (like interrupts etc) but there is a limitation that we can only use one instance of them. +--------------------------+ | | +------+---+ +---------+ | | | | | | | Qemu | | Qemu +------+ | | | | | | | +----+-----+ +-----+---+ | | | | | | +----+---------------+---+ +--+-+--+ | KVM | | Memory| +------------------------+ +-------+ In mumu we designed a simple principle; each startup we inject a shared memory map into memory region (currently 0x14000). The operating system knows in which area the shared memories are here. Then, it can read and write to these addresses. At the same time, we can grant write and read permissions to these regions in the XML file. Thanks to this, while a vm partition is writing, other vm partitions can only listen. This feature is used for the sampling port. +---------------+ |+++++++++++++++| Shared Memory 1 0x600000 +---------------+ <------+ | | | | | | | | +---------------------+ | | | | | | | | | +---------------+ | |0x140000 | | |Shared Infos +---+ | +---------------+ | +--------+---------+ | | | | | mem1 |0x6000000+---+ | | | +--------+---------+ | | | | mem2 |0x8000000| | | +-->+--------+---------+ +---------------+","title":"Architecture & Design"},{"location":"architecture/#architecture-design","text":"mumu uses KVM in the background to run virtual machines. It also makes use of posix threads and posix libraries.","title":"Architecture &amp; Design"},{"location":"architecture/#partition-vm","text":"mumu calls each VM as Partition VM . From now on partition vms will be referred to as partition. When a partition starts, it have a 6MB of space. In this area, page tables are given to the user as a 1:1 map. In this way, injection can be made easily through physical and virtual addresses during the first boot phase. +--------------------+ 0x0000000 User Start |++++++++++++++++++++| |++++++++++++++++++++| |++++++++++++++++++++| |++++++++++++++++++++| |++++++++++++++++++++| +--------------------+ 0x1000000 Page Table Entries | | +--------------------+ | | +--------------------+ | | +--------------------+ 0x1400000 Channel Informations | | | ^ ^ ^ | | | | | | | | | | | 0x600000 Stack +---+-----+-----+----+ SINGLE PARTITION Partitions should be defined under the <Partitions> node in XML file. Each partition should similar to this: <Partition> <PartitionDefinition Identifier=\"1\" Name=\"test1\" BinaryPath=\"hello.bin\" ScheduleChangeAction=\"IDLE\" SetModuleSchedule=\"false\" SystemPartition=\"true\"/> <PartitionPeriodicity Duration=\"20000000\" Period=\"3000\"/> <CoreAffinity> <CoreMapping LogicalCoreId=\"0\" PhysicalCoreId=\"3\"/> <CoreMapping LogicalCoreId=\"1\" PhysicalCoreId=\"2\"/> </CoreAffinity> </Partition>","title":"Partition VM"},{"location":"architecture/#multicore","text":"mumu can run different vcpu\u2019s in different cores thanks to posix threads. In XML file programmers should explicitly define affinity of the cores. +-------+---------------+ |Core 1 | VM-1 VCPU1 | +-------+---------------+ |Core 2 | VM-1 VCPU2 | +-------+---------------+ |Core 3 | VM-2 VCPU1 | +-------+---------------+ In XML file programmer should define as follow: <CoreAffinity> <CoreMapping LogicalCoreId=\"0\" PhysicalCoreId=\"3\"/> <CoreMapping LogicalCoreId=\"1\" PhysicalCoreId=\"2\"/> </CoreAffinity>","title":"Multicore"},{"location":"architecture/#static-scheduling","text":"Static scheduling is a mechanism that allows to regulate the order in which threads execute in the code. When we look at the mumu level, we see that these are vms. 0ms 50ms 120ms 150ms +------------+-------------------+-----------+ Core 1 | VM1 VCPU1 | VM3 VCPU1 | VM2 VCPU3 | +------------+-------------------+-----------+ Core 2 | VM1 VCPU2 | VM2 VCPU2 | VM1 VCPU2 | +------------+-------------------+-----------+ Core 3 | VM2 VCPU2 | VM1 VCPU1 | VM2 VCPU2 | +------------+-------------------+-----------+ Core 4 | VM3 VCPU1 | VM2 VCPU1 | VM1 VCPU1 | +------------+-------------------+-----------+ We can measure scheduling times with uftrace thanks to the mumu runs on C++. The static schedule structure can be seen on uftrace as follows. Scheduling times can be configured through XML file. <Schedules MajorFrameDuration=\"60000000\" ScheduleIdentifier=\"1\" InitialModuleSchedule=\"true\"> <PartitionTimeWindow PartitionNameRef=\"test1\" Duration=\"2000\" Offset=\"0\" /> <PartitionTimeWindow PartitionNameRef=\"test2\" Duration=\"2000\" Offset=\"20000000\" /> <PartitionTimeWindow PartitionNameRef=\"test1\" Duration=\"2000\" Offset=\"40000000\" /> <PartitionTimeWindow PartitionNameRef=\"test1\" Duration=\"2000\" Offset=\"60000000\" /> </Schedules>","title":"Static Scheduling"},{"location":"architecture/#shared-memory","text":"Qemu uses the ivshmem infrastructure for shared memory. Actually, ivhsmem is installed in Linux devices as a PCI device. Then, communication can take place by read and write syscalls to these PCI devices. Ivhsmem has a lot of features (like interrupts etc) but there is a limitation that we can only use one instance of them. +--------------------------+ | | +------+---+ +---------+ | | | | | | | Qemu | | Qemu +------+ | | | | | | | +----+-----+ +-----+---+ | | | | | | +----+---------------+---+ +--+-+--+ | KVM | | Memory| +------------------------+ +-------+ In mumu we designed a simple principle; each startup we inject a shared memory map into memory region (currently 0x14000). The operating system knows in which area the shared memories are here. Then, it can read and write to these addresses. At the same time, we can grant write and read permissions to these regions in the XML file. Thanks to this, while a vm partition is writing, other vm partitions can only listen. This feature is used for the sampling port. +---------------+ |+++++++++++++++| Shared Memory 1 0x600000 +---------------+ <------+ | | | | | | | | +---------------------+ | | | | | | | | | +---------------+ | |0x140000 | | |Shared Infos +---+ | +---------------+ | +--------+---------+ | | | | | mem1 |0x6000000+---+ | | | +--------+---------+ | | | | mem2 |0x8000000| | | +-->+--------+---------+ +---------------+","title":"Shared Memory"},{"location":"examples/","text":"Examples Loading x86 Assembly In mumu you can load different type of x86 assemblies. Currently mumu starts in long mode. So you should start the operating system with 32bit or 64 bit mode. 16 bit Real Mode To enable 16 bit real mode you should remove page_table configurations. Sample program: .globl _start .code16 _start: xorw %ax, %ax loop: out %ax, $0xf1 inc %ax jmp loop assemble this program and extract text section. 64 bit Long Mode _start: xorw %dax, %dax loop: out %dax, $0xf1 inc %dax jmp loop Loading Simple C Program It\u2019s possible to run bare metal C programs inside mumu. Also, there is a common.h library that programmers can be use. To run bare metal applications you should avoid of dynamic linking and external libraries (it\u2019s ok when you compile with static linking). Program: #include \"common.h\" void main(){ char a[5] = {'H','e','l','l','o'}; for(int k = 0; k < 5; k++){ write(a[k]); } } Directory and makefile cd examples/hello-world make Output: Hello World ! Using XML File Create a XML parser. xml_parser* parser = new xml_parser(); auto parsed_vms = parser->parse(\"/home/musa/test.xml\"); Set up VMs with parsed data: auto vm_list = new list<VM*>(); for(auto l: *parsed_vms){ VM *vm = new VM(_kvm); for(auto k = 0; k < l->cores.size(); k++){ vm->create_vcpu(k,l->cores[k]->core_id,l->cores[k]->physical_core_map); } vm->mem_init(); vm->load_binary(l->binary_path); l->vm = vm; vm_list->push_back(vm); } Static Scheduling In order to use static scheduler you should parse information from XMl file. #include <iostream> auto sched_info = parser->generate_core_scheduling_order(parser->windows); vector<Scheduler*> scheduler_list; for(auto core = 0; core<4; core++){ Scheduler* sch = new Scheduler(&sched_info[core],core); scheduler_list.push_back(sch); } Multicore Application Using Serial Console Shared Memory Inter VM Communication Sampling Port","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#loading-x86-assembly","text":"In mumu you can load different type of x86 assemblies. Currently mumu starts in long mode. So you should start the operating system with 32bit or 64 bit mode.","title":"Loading x86 Assembly"},{"location":"examples/#16-bit-real-mode","text":"To enable 16 bit real mode you should remove page_table configurations. Sample program: .globl _start .code16 _start: xorw %ax, %ax loop: out %ax, $0xf1 inc %ax jmp loop assemble this program and extract text section.","title":"16 bit Real Mode"},{"location":"examples/#64-bit-long-mode","text":"_start: xorw %dax, %dax loop: out %dax, $0xf1 inc %dax jmp loop","title":"64 bit Long Mode"},{"location":"examples/#loading-simple-c-program","text":"It\u2019s possible to run bare metal C programs inside mumu. Also, there is a common.h library that programmers can be use. To run bare metal applications you should avoid of dynamic linking and external libraries (it\u2019s ok when you compile with static linking). Program: #include \"common.h\" void main(){ char a[5] = {'H','e','l','l','o'}; for(int k = 0; k < 5; k++){ write(a[k]); } } Directory and makefile cd examples/hello-world make Output: Hello World !","title":"Loading Simple C Program"},{"location":"examples/#using-xml-file","text":"Create a XML parser. xml_parser* parser = new xml_parser(); auto parsed_vms = parser->parse(\"/home/musa/test.xml\"); Set up VMs with parsed data: auto vm_list = new list<VM*>(); for(auto l: *parsed_vms){ VM *vm = new VM(_kvm); for(auto k = 0; k < l->cores.size(); k++){ vm->create_vcpu(k,l->cores[k]->core_id,l->cores[k]->physical_core_map); } vm->mem_init(); vm->load_binary(l->binary_path); l->vm = vm; vm_list->push_back(vm); }","title":"Using XML File"},{"location":"examples/#static-scheduling","text":"In order to use static scheduler you should parse information from XMl file. #include <iostream> auto sched_info = parser->generate_core_scheduling_order(parser->windows); vector<Scheduler*> scheduler_list; for(auto core = 0; core<4; core++){ Scheduler* sch = new Scheduler(&sched_info[core],core); scheduler_list.push_back(sch); }","title":"Static Scheduling"},{"location":"examples/#multicore-application","text":"","title":"Multicore Application"},{"location":"examples/#using-serial-console","text":"","title":"Using Serial Console"},{"location":"examples/#shared-memory","text":"","title":"Shared Memory"},{"location":"examples/#inter-vm-communication","text":"","title":"Inter VM Communication"},{"location":"examples/#sampling-port","text":"","title":"Sampling Port"},{"location":"gsg/","text":"Getting Started Before running mumu, you need to meet some prerequisites. Once you\u2019re sure you\u2019ve provided them, you can start mumu. Hardware Minimum Requirement Processor x86 64-bit processor and VT-x Technology must be enabled Memory 4 GB You need a Linux machine to run mumu. Also, check your hardware support for VT-x technology. cat /proc/cpuinfo | grep vmx Important Header Files #include \"../lib/hypervisor/kvm/kvm.h\" #include \"../lib/hypervisor/kvm/vm.h\" #include \"../lib/hypervisor/kvm/vcpu.h\" mumu needs three core header files to create virtual machines. Creating VM\u2019s It\u2019s very easy to create VM\u2019s inside mumu. First, user should connect to the KVM with KVM class. KVM *_kvm = new KVM(); _kvm->init(); After, user can create virtual machines. VM *vm = new VM(_kvm); vm->create_vcpu(0, 0, 0); vm->mem_init(); Loading Binaries It\u2019s very easy to load binary files to virtual machines in mumu. There is a function called load_text_binary(char* hex) which takes a binary as char array and load into virtual machine or you can load from file: load_binary_data(\"hello_world.bin\"); Loading Elf Files It is possible to inject elf files directly into virtual machine. it is also important that the C files are compiled correctly. First of all, you should remember that the program must be compiled with static linking. load_elf(\"/home/mumu_visor/Hello World/IO Devices/prog\",vm); auto s_address = get_entry_address(\"/home/mumu_visor/Hello World/IO Devices/prog\"); Setup Mode There are 3 different modes that mumu can support: Real Mode 32 bit Protected Mode 64 bit Long Mode run_long_mode(vm,vm->vcpus[0],s_address); Run Virtual Machine It\u2019s possible to run and stop virtual machine with simple functions. vm->run_vm(); vm->stop_vm(); Simple Hello World Program #include \"../lib/hypervisor/kvm/kvm.h\" #include \"../lib/hypervisor/kvm/vm.h\" #include \"../lib/hypervisor/kvm/vcpu.h\" #include \"../lib/hypervisor/kvm/modes.h\" #include \"../lib/hypervisor/loader/mumu_elf.hpp\" int main() { KVM *_kvm = new KVM(); _kvm->init(); VM *vm = new VM(_kvm); vm->create_vcpu(0, 0, 0); vm->mem_init(); auto s_address = load_elf(\"./helloworld\",vm); run_long_mode(vm,vm->vcpus[0],s_address); vm->run_vm(); vm->stop_vm(); } Output: ------- mumu started ---------- KVM version 12 VM created VCPU init success Testing 64-bit mode core: 0 140737341830912 ------------------------------- CPU init with id: 324977 core: 0 id: 324977 core: 0 id: 0 data: H id: 324977 core: 0 id: 0 data: e id: 324977 core: 0 id: 0 data: l id: 324977 core: 0 id: 0 data: l id: 324977 core: 0 id: 0 data: o id: 324977 core: 0 id: 0 data: id: 324977 core: 0 id: 0 data: W id: 324977 core: 0 id: 0 data: o id: 324977 core: 0 id: 0 data: r id: 324977 core: 0 id: 0 data: l id: 324977 core: 0 id: 0 data: d halted","title":"Getting Started"},{"location":"gsg/#getting-started","text":"Before running mumu, you need to meet some prerequisites. Once you\u2019re sure you\u2019ve provided them, you can start mumu. Hardware Minimum Requirement Processor x86 64-bit processor and VT-x Technology must be enabled Memory 4 GB You need a Linux machine to run mumu. Also, check your hardware support for VT-x technology. cat /proc/cpuinfo | grep vmx","title":"Getting Started"},{"location":"gsg/#important-header-files","text":"#include \"../lib/hypervisor/kvm/kvm.h\" #include \"../lib/hypervisor/kvm/vm.h\" #include \"../lib/hypervisor/kvm/vcpu.h\" mumu needs three core header files to create virtual machines.","title":"Important Header Files"},{"location":"gsg/#creating-vms","text":"It\u2019s very easy to create VM\u2019s inside mumu. First, user should connect to the KVM with KVM class. KVM *_kvm = new KVM(); _kvm->init(); After, user can create virtual machines. VM *vm = new VM(_kvm); vm->create_vcpu(0, 0, 0); vm->mem_init();","title":"Creating VM's"},{"location":"gsg/#loading-binaries","text":"It\u2019s very easy to load binary files to virtual machines in mumu. There is a function called load_text_binary(char* hex) which takes a binary as char array and load into virtual machine or you can load from file: load_binary_data(\"hello_world.bin\");","title":"Loading Binaries"},{"location":"gsg/#loading-elf-files","text":"It is possible to inject elf files directly into virtual machine. it is also important that the C files are compiled correctly. First of all, you should remember that the program must be compiled with static linking. load_elf(\"/home/mumu_visor/Hello World/IO Devices/prog\",vm); auto s_address = get_entry_address(\"/home/mumu_visor/Hello World/IO Devices/prog\");","title":"Loading Elf Files"},{"location":"gsg/#setup-mode","text":"There are 3 different modes that mumu can support: Real Mode 32 bit Protected Mode 64 bit Long Mode run_long_mode(vm,vm->vcpus[0],s_address);","title":"Setup Mode"},{"location":"gsg/#run-virtual-machine","text":"It\u2019s possible to run and stop virtual machine with simple functions. vm->run_vm(); vm->stop_vm();","title":"Run Virtual Machine"},{"location":"gsg/#simple-hello-world-program","text":"#include \"../lib/hypervisor/kvm/kvm.h\" #include \"../lib/hypervisor/kvm/vm.h\" #include \"../lib/hypervisor/kvm/vcpu.h\" #include \"../lib/hypervisor/kvm/modes.h\" #include \"../lib/hypervisor/loader/mumu_elf.hpp\" int main() { KVM *_kvm = new KVM(); _kvm->init(); VM *vm = new VM(_kvm); vm->create_vcpu(0, 0, 0); vm->mem_init(); auto s_address = load_elf(\"./helloworld\",vm); run_long_mode(vm,vm->vcpus[0],s_address); vm->run_vm(); vm->stop_vm(); } Output: ------- mumu started ---------- KVM version 12 VM created VCPU init success Testing 64-bit mode core: 0 140737341830912 ------------------------------- CPU init with id: 324977 core: 0 id: 324977 core: 0 id: 0 data: H id: 324977 core: 0 id: 0 data: e id: 324977 core: 0 id: 0 data: l id: 324977 core: 0 id: 0 data: l id: 324977 core: 0 id: 0 data: o id: 324977 core: 0 id: 0 data: id: 324977 core: 0 id: 0 data: W id: 324977 core: 0 id: 0 data: o id: 324977 core: 0 id: 0 data: r id: 324977 core: 0 id: 0 data: l id: 324977 core: 0 id: 0 data: d halted","title":"Simple Hello World Program"},{"location":"reference/","text":"Reference Warning This section is under development. KVM Functions init() int KVM::init(); Returns : file descriptor of KVM instance get_fd() uint32_t KVM::get_fd() const; Returns : file descriptor of KVM instance get_version() uint32_t KVM::get_version() const; Returns : version of KVM instance VM Functions VM() VM(KVM *_ref); Returns : VM object Description : Creates VM with KVM_CREATE_VM ioctl VCPU* create_vcpu() VCPU* create_vcpu(int, uint8_t, uint8_t) Returns : VCPU object Args : int _id, uint8_t _virtual_core, uint8_t _physical_core Description : Creates VM with KVM_CREATE_VM ioctl load_binary() void load_binary(const string _file); Returns : none Description : Load binary from a file load_text_binary() void load_text_binary(uint8_t[],int); Returns : none Description : Load binary from char array mem_init() int mem_init(); Returns : 1 on success -1 on error Description : Initialize memory region for VM. VCPU Functions VCPU() VCPU(){}; Returns : VCPU object Description : Default constructor. VCPU(...) VCPU(int, int, struct kvm_run*,int) Returns : VCPU object Description : Extended constructor. run() void run(int,int); Returns : none Args : core, sec Description : Run VCPU thread. run_real_mode() int run_real_mode(); Returns : -1 on error 1 on success Description : Configure VCPU for running on real mode run_protected_mode() int run_protected_mode(); Returns : -1 on error 1 on success Description : Configure VCPU for running on protected mode set_cores() void set_cores(int, int); Returns : none Args : physical core, virtual core Description : Configure VCPU cores setup_segment_registers() void setup_segment_registers(); Returns : none Description : Configure segment registers for 32 bit and 64 mode page_tables() void page_tables(void* mem, struct kvm_sregs *sregs) Returns : none Args : memory region, register struct Description : Setup page tables for 64bit long mode","title":"Reference"},{"location":"reference/#reference","text":"Warning This section is under development.","title":"Reference"},{"location":"reference/#kvm-functions","text":"","title":"KVM Functions"},{"location":"reference/#init","text":"int KVM::init(); Returns : file descriptor of KVM instance","title":"init()"},{"location":"reference/#get_fd","text":"uint32_t KVM::get_fd() const; Returns : file descriptor of KVM instance","title":"get_fd()"},{"location":"reference/#get_version","text":"uint32_t KVM::get_version() const; Returns : version of KVM instance","title":"get_version()"},{"location":"reference/#vm-functions","text":"","title":"VM Functions"},{"location":"reference/#vm","text":"VM(KVM *_ref); Returns : VM object Description : Creates VM with KVM_CREATE_VM ioctl","title":"VM()"},{"location":"reference/#vcpu-create_vcpu","text":"VCPU* create_vcpu(int, uint8_t, uint8_t) Returns : VCPU object Args : int _id, uint8_t _virtual_core, uint8_t _physical_core Description : Creates VM with KVM_CREATE_VM ioctl","title":"VCPU* create_vcpu()"},{"location":"reference/#load_binary","text":"void load_binary(const string _file); Returns : none Description : Load binary from a file","title":"load_binary()"},{"location":"reference/#load_text_binary","text":"void load_text_binary(uint8_t[],int); Returns : none Description : Load binary from char array","title":"load_text_binary()"},{"location":"reference/#mem_init","text":"int mem_init(); Returns : 1 on success -1 on error Description : Initialize memory region for VM.","title":"mem_init()"},{"location":"reference/#vcpu-functions","text":"","title":"VCPU Functions"},{"location":"reference/#vcpu","text":"VCPU(){}; Returns : VCPU object Description : Default constructor.","title":"VCPU()"},{"location":"reference/#vcpu_1","text":"VCPU(int, int, struct kvm_run*,int) Returns : VCPU object Description : Extended constructor.","title":"VCPU(...)"},{"location":"reference/#run","text":"void run(int,int); Returns : none Args : core, sec Description : Run VCPU thread.","title":"run()"},{"location":"reference/#run_real_mode","text":"int run_real_mode(); Returns : -1 on error 1 on success Description : Configure VCPU for running on real mode","title":"run_real_mode()"},{"location":"reference/#run_protected_mode","text":"int run_protected_mode(); Returns : -1 on error 1 on success Description : Configure VCPU for running on protected mode","title":"run_protected_mode()"},{"location":"reference/#set_cores","text":"void set_cores(int, int); Returns : none Args : physical core, virtual core Description : Configure VCPU cores","title":"set_cores()"},{"location":"reference/#setup_segment_registers","text":"void setup_segment_registers(); Returns : none Description : Configure segment registers for 32 bit and 64 mode","title":"setup_segment_registers()"},{"location":"reference/#page_tables","text":"void page_tables(void* mem, struct kvm_sregs *sregs) Returns : none Args : memory region, register struct Description : Setup page tables for 64bit long mode","title":"page_tables()"}]}